import pygame
from enum import Enum, auto
import numpy as np
import threading
import platform


# TODO: File divisions
# TODO: Add docstrings

class Status(Enum):
    NORMAL = auto()
    DEADING = auto()
    DEAD = auto()
    TREADING = auto()
    SLIDING = auto()
    FLYING = auto()
    GROWING = auto()
    SHRINKING = auto()
    ENTERING = auto()
    APPEARING = auto()
    GOAL = auto()
    CLEAR = auto()
    PAUSE = auto()
    INIT = auto()
    OPENING = auto()
    GAMEOVER = auto()


class GoalStatus(Enum):
    IDLE = auto()
    MARIO_FALL = auto()
    MARIO_TURN = auto()
    MARIO_WALK = auto()
    MARIO_ENTER_CASTLE = auto()
    SCORE_CALCULATION = auto()
    CASTLE_FLAG_RISE = auto()
    FIREWORKS = auto()
    DONE = auto()
    

GOAL_ANIMATION_SCRIPTS: dict = {
    "World1-1": [
        {"phase": GoalStatus.MARIO_FALL,          "start": 0,  "end": 49},
        {"phase": GoalStatus.MARIO_TURN,          "start": 50, "end": 50},
        {"phase": GoalStatus.MARIO_WALK,          "start": 51, "end": 68},
        {"phase": GoalStatus.MARIO_ENTER_CASTLE,  "start": 69, "end": 70},
        {"phase": GoalStatus.SCORE_CALCULATION,   "start": 71, "end": 71},
        {"phase": GoalStatus.CASTLE_FLAG_RISE,    "start": 72, "end": 81},
        {"phase": GoalStatus.FIREWORKS,           "start": 82, "end": 118,},
        {"phase": GoalStatus.DONE,                "start": 119, "end": 119},
    ],
    # Other Worlds in the future
}


class GoalManager:
    # base location x=4120, y=100
    # TODO: Update the correct locations
    FIREWORKS_LOC: tuple= (
        (4100, 100),
        (4040, 140),
        (4160, 140),
        (4070, 160),
        (4130, 160),
        (4110, 100)
    )
    
    FIREWORKS_TIMING: tuple = (83, 88, 93, 98, 103, 108)
    
    # To make sure if there is a bug/ unnecessary process/code, variables and so on....
    # Add TODO for the future improvements
    # How about relocating the following consts in this GoalManager class?
    # GOAL_ANIMATION_SCRIPTS and GoalStatus
    
    def __init__(self, world_name: str, mario, map) -> None:        
        self.__script: dict = GOAL_ANIMATION_SCRIPTS[world_name]
        self.__counter: int = 0
        self.__phase: int = GoalStatus.IDLE
        self.__isactive: bool = False
        
        self.__map = map
        self.__map.goal_manager = self
        
        self.__mario = mario
        self.__castle_flag = None
        self.__fireworks: list[Fireworks] = None
        self.__num_fireworks: int = 0
        
    @property
    def phase(self):
        return self.__phase
    
    @property
    def castle_flag(self):
        return self.__castle_flag
    
    @castle_flag.setter
    def castle_flag(self, value):
        self.__castle_flag = value
    
    @property
    def fireworks(self):
        return self.__fireworks
    
    @fireworks.setter
    def fireworks(self, value):
        self.__fireworks = value
    
    def update(self) -> None:
        
        if not self.__isactive:
            return
        
        if self.__phase == GoalStatus.MARIO_FALL:
            self.__mario.slide_down_pole()
                
        elif self.__phase == GoalStatus.MARIO_TURN:
            self.__mario.change_side()
        
        elif self.__phase == GoalStatus.MARIO_WALK:
            self.__mario.walk_to_castle()
        
        elif self.__phase == GoalStatus.MARIO_ENTER_CASTLE:
            self.__mario.enter_castle()
        
        elif self.__phase == GoalStatus.SCORE_CALCULATION:
            # Return until the calculation ends
            if not self.__map.add_timer_score():
                return
        
        elif self.__phase == GoalStatus.CASTLE_FLAG_RISE:
            self.__castle_flag.rise()
        
        elif self.__phase == GoalStatus.FIREWORKS:
            if self.__counter == 82:
                # Get the first digit of timer
                first_digit = int(str(self.__map.goal_time)[-1])
                
                # fireworks launches if the first digit of timer is 1 or 3 or 6
                if first_digit in [1, 3, 6]:
                    fireworks = [None] * first_digit
                    for i in range(0, first_digit):
                        fireworks[i] = Fireworks(self.FIREWORKS_LOC[i][0], self.FIREWORKS_LOC[i][1], 
                                                 0, self.__mario, self.__map, self)
                    self.__fireworks = fireworks
            else:
                # Fireworks lauch unless fireworks is none
                if self.__fireworks:
                    if self.__num_fireworks < len(self.__fireworks):
                        if self.__counter == self.FIREWORKS_TIMING[self.__num_fireworks]:
                            self.__map.group.add(self.__fireworks[self.__num_fireworks])
                            self.__map.add_score(500)
                            self.__num_fireworks += 1

        elif self.__phase == GoalStatus.DONE:
            self.__isactive = False
            self.__counter = 0
            
            # Change Mario status
            self.__mario.status = Status.CLEAR
            return
        
        self.__counter += 1
        self.__update_phase()
    
    def __update_phase(self) -> None:
        for phase_info in self.__script:
            if phase_info['start'] <= self.__counter <= phase_info['end']:
                self.__phase = phase_info['phase']
                return
            
    @property
    def isactive(self):
        return self.__isactive
    
    @isactive.setter
    def isactive(self, value):
        self.__isactive = value


# Display size
W, H = 320, 270

# Number of tiles
TILE_X, TILE_Y = 16, 14

# Array for socre
SCORE_ARRAY: list[int] = [100, 200, 400, 500, 800, 1000, 2000, 4000, 5000, 8000]
ONEUP_SCORE: str = '1UP'

# GOAL
GOAL_BOTTOM_Y: int = 220  # Bottom position for the goal flag
GOAL_FALL_SPEED: int = 5  # falling speed for both Mario and goal flag


class Map():
    # TODO: standardize these code: startx + TILE_X, startx + TILE_X + 1, xidx + 1

    NOMOVE_X = 120
    BLOCK_VY = 5
    BLOCK_GROUND = 1
    BLOCK_NORMAL = 2
    BLOCK_QUESTION = 3
    BLOCK_PANEL = 4
    BLOCK_STAIRS = 5
    PIPE_1 = 6
    PIPE_2 = 7
    PIPE_3 = 8
    PIPE_4 = 9
    BLOCK_INVISIBLE = 0x0A
    BLOCK_STAR = 0x0B

    PUSHED_BLOCKS = [BLOCK_NORMAL, BLOCK_QUESTION, BLOCK_INVISIBLE, BLOCK_STAR]
    
    # Sub stage
    PIPE_5 = 0x0C  # Top left
    PIPE_6 = 0x0D  # Top right
    PIPE_7 = 0x0E  # Bottom right
    PIPE_8 = 0x0F  # Bottom left

    CASTLE_1 = 0x80
    CASTLE_2 = 0x81
    CASTLE_3 = 0x82
    CASTLE_4 = 0x83
    CASTLE_5 = 0x84
    CASTLE_6 = 0x85

    GOAL_POLE_1 = 0x86
    GOAL_POLE_2 = 0x87  
    GOAL_FLAG = 0x88
    
    def __init__(self, group, group_bg, sound, hud, world) -> None:
        # Map index
        self.__map_idx: int = 0

        # Background color
        self.__bg_color = ((135, 206, 235), (0, 0, 0))

        # Warp infomation (xidx, yidx): (map_idx, xidx, yidx, direction to enter) 
        # direction(0: None, 1: down, 2: right, 3: top, 4: left) 
        self.__warp_info: dict = {
            0: {(59, 8): (1, 1, 1, 1, 0), (60, 8): (1, 1, 1, 1, 0), (59, 7): (1, 1, 1, 1, 0), (60, 7): (1, 1, 1, 1, 0)}, 
            1: {(12, 11): (0, 165, 10, 2, 3), (12, 10): (0, 165, 10, 2, 3)}
            }
                
        pipe_1, pipe_2 = pygame.image.load('./img/pipe_1.jpg'), pygame.image.load('./img/pipe_2.jpg')
        castle_2 = pygame.image.load('./img/castle_2.jpg')
        block_ground = pygame.image.load('./img/ground.jpg')
        self.__imgs: dict = {
            self.BLOCK_GROUND: (block_ground, pygame.image.load('./img/ground_sub.jpg')),
            self.BLOCK_NORMAL: (pygame.image.load('./img/block.jpg'), pygame.image.load('./img/block_sub.jpg')),
            self.BLOCK_QUESTION: pygame.image.load('./img/question_block.jpg'),
            self.BLOCK_PANEL: pygame.image.load('./img/panel.jpg'),
            self.PIPE_1: pipe_1,
            self.PIPE_2: pipe_2,
            self.PIPE_3: pygame.image.load('./img/pipe_3.jpg'),
            self.PIPE_4: pygame.image.load('./img/pipe_4.jpg'),
            self.BLOCK_STAIRS: pygame.image.load('./img/stairs_block.jpg'),
            self.BLOCK_STAR: pygame.image.load('./img/block.jpg'),
            self.PIPE_5: pygame.transform.rotate(pipe_1, 90),
            self.PIPE_6: pygame.transform.rotate(pipe_2, 90),
            self.PIPE_7: pygame.image.load('./img/pipe_5.jpg'),
            self.PIPE_8: pygame.image.load('./img/pipe_6.jpg'),
            self.CASTLE_1: pygame.image.load('./img/castle_1.jpg'),
            self.CASTLE_2: castle_2,
            self.CASTLE_3: pygame.transform.rotate(castle_2, 180),
            self.CASTLE_4: pygame.image.load('./img/castle_4.jpg'),
            self.CASTLE_5: pygame.image.load('./img/castle_5.jpg'),
            self.CASTLE_6: block_ground,
            self.GOAL_POLE_1: pygame.image.load('./img/goal_post_1.jpg'),
            self.GOAL_POLE_2: pygame.image.load('./img/goal_post_2.jpg'),
            }
        
        # Mario info
        self.__mario = None
        
        self.__goal_manager = None
        
        # Sprite groups
        self.__group = group
        self.__group_bg = group_bg
        
        # Set Sound class
        self.__sound = sound
        
        # Set HeadUpDisplay class
        self.__hud = hud
        self.__score: int = 0
        self.__coin: int = 0
        self.__world: str = world
        self.__goal_time: int = None
        self.__life_stocks: int = 3
        
        # Common initialization
        self.__common_init()
        
        # Draw entity 
        for xidx in range(TILE_X):
            self.__create_entity(xidx)

    def __common_init(self) -> None:
        # Define map
        self.__data = [
            [
                [0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000],
                [0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000],
                [0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0086, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000],
                [0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0800, 0x0087, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000],
                [0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0087, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000],
                [0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0503, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0503, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0303, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0503, 0x0503, 0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0005, 0x0005, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0087, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000],
                [0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0005, 0x0005, 0x0005, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0087, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000],
                [0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0005, 0x0005, 0x0005, 0x0005, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0087, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000],
                [0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x060A, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0087, 0x0000, 0x0000, 0x0000, 0x0000, 0x0080, 0x0980, 0x0080, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000],
                [0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0503, 0x0000, 0x0000, 0x0000, 0x0002, 0x0303, 0x0002, 0x0503, 0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0006, 0x0007, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0006, 0x0007, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0303, 0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x040B, 0x0000, 0x0000, 0x0000, 0x0000, 0x0503, 0x0000, 0x0000, 0x0503, 0x0000, 0x0000, 0x0503, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0005, 0x0000, 0x0000, 0x0005, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0005, 0x0005, 0x0000, 0x0000, 0x0005, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0503, 0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0087, 0x0000, 0x0000, 0x0000, 0x0000, 0x0081, 0x0002, 0x0082, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000],
                [0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0006, 0x0007, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0005, 0x0005, 0x0000, 0x0000, 0x0005, 0x0005, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0005, 0x0005, 0x0005, 0x0000, 0x0000, 0x0005, 0x0005, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0087, 0x0000, 0x0000, 0x0000, 0x0080, 0x0083, 0x0083, 0x0083, 0x0080, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000],
                [0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0006, 0x0007, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0005, 0x0005, 0x0005, 0x0000, 0x0000, 0x0005, 0x0005, 0x0005, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0005, 0x0005, 0x0005, 0x0005, 0x0000, 0x0000, 0x0005, 0x0005, 0x0005, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0006, 0x0007, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0006, 0x0007, 0x0000, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0087, 0x0000, 0x0000, 0x0000, 0x0085, 0x0085, 0x0084, 0x0085, 0x0085, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000],
                [0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0100, 0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0005, 0x0005, 0x0005, 0x0005, 0x0000, 0x0000, 0x0005, 0x0005, 0x0005, 0x0005, 0x0000, 0x0000, 0x0000, 0x0000, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0000, 0x0000, 0x0005, 0x0005, 0x0005, 0x0005, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000, 0x0008, 0x0009, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0005, 0x0000, 0x0000, 0x0000, 0x0085, 0x0085, 0x0084, 0x0085, 0x0085, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000],
                [0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0000, 0x0000, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0000, 0x0000, 0x0000, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0000, 0x0000, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001],
                [0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0000, 0x0000, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0000, 0x0000, 0x0000, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0000, 0x0000, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001],
                [0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000], 
            ],
            [
                [0x0002, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009],
                [0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009],
                [0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009],
                [0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009],
                [0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0700, 0x0700, 0x0700, 0x0700, 0x0700, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009],
                [0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009],
                [0x0002, 0x0000, 0x0000, 0x0000, 0x0700, 0x0700, 0x0700, 0x0700, 0x0700, 0x0700, 0x0700, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009],
                [0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009],
                [0x0002, 0x0000, 0x0000, 0x0000, 0x0700, 0x0700, 0x0700, 0x0700, 0x0700, 0x0700, 0x0700, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009],
                [0x0002, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009],
                [0x0002, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0x0000, 0x000D, 0x000E, 0x0008, 0x0009],
                [0x0002, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0x0000, 0x000C, 0x000F, 0x0008, 0x0009],
                [0x0002, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001],
                [0x0002, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001],
                [0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000],
                [0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000],
            ]
        ]
    
        # Map shifts relative to Mario's position
        self.__drawmargin: int = 0
        
        # X coordinate on the left edge of the map
        self.__nowx: int = 0
    
        # Array for pushed blocks
        self.__pushedblocks: dict = {}
        
        # Timer
        self.__timer: float = 400

    def init_dead(self) -> pygame.sprite:
        self.__common_init()
        self.__group, self.__group_bg = pygame.sprite.RenderUpdates(), pygame.sprite.RenderUpdates()
        return self.__group, self.__group_bg
    
    @property
    def mario(self):
        return self.__mario
    
    @mario.setter
    def mario(self, value):
        self.__mario = value
    
    @property
    def goal_manager(self):
        return self.__goal_manager
    
    @goal_manager.setter
    def goal_manager(self, value):
        self.__goal_manager = value
    
    @property
    def nowx(self):
        """Get X coordinate on the left edge of the map"""
        return self.__nowx
    
    @property
    def group(self):
        return self.__group
    
    @property
    def sound(self):
        return self.__sound
    
    @property
    def hud(self):
        return self.__hud
    
    @property
    def score(self):
        return self.__score
    
    @property
    def coin(self):
        return self.__coin
    
    @property
    def timer(self):
        return self.__timer
    
    @property
    def goal_time(self):
        return self.__goal_time
    
    @goal_time.setter
    def goal_time(self, value):
        self.__goal_time = value
    
    @property
    def warp_info(self):
        return self.__warp_info[self.__map_idx]

    def get_mapdata(self, x: int, y: int) -> int:
        """
        Get data from the lower 8 bit on the map, corresponding to x, y coordinate tile.
        
        The function returns only the lowest 8 bits of the tile's value, discarding any higher bits.
        0xFF is hexadecimal for decimal 255 (binary: 1111 1111).
        The bitwise AND with 0xFF is a common trick to extract just these bits.
        
        Args:
            x (int): X axle on the map data
            y (int): Y axle on the map data

        Returns:
            int: The lower 8 bit block data
        """
        return self.__data[self.__map_idx][y][x] & 0x00FF

    def is_goal_block(self, x: int, y: int) -> bool:
        """
        Check whether the tile at (x, y) tile is a goal-block obstacle (Goal pole or castle). 

        Obstacles related to the goal blocks are marked by the 0x0080 bit in the map data.
        This function determines collision avoidance when Mario interacts with the goal pole or castle.

        Args:
            x (int): X axle on the map data
            y (int): Y axle on the map data
        Returns:
            bool: True if the tile's data contains the goal-block (0x0080), False otherwise.
        """
        return self.__data[self.__map_idx][y][x] & 0x0080 != 0
    
    def set_mapdata(self, x: int, y: int, val: int) -> None:
        """
        Set data to the lower 8 bits on the map data
        
        self.__data[y][x] & 0xFF00:
            Clears the lower 8 bits using and of 0xFF00, keeping only the upper 8 bits

        val & 0x00FF:
            Extracting only the 8 bits of val, ensuring the data fits within one byte (0-255).

        Args:
            x (int): X axle on Map
            y (int): Y axle on Map
            val (int): object data such as block
        """
        self.__data[self.__map_idx][y][x] = (self.__data[self.__map_idx][y][x] & 0xFF00) | (val & 0x00FF)
        
    def get_upper(self, n):
        """Get the upper 8 bit by shifting 8 bits to the right"""
        return (n >> 8) & 0x00FF
    
    def get_entitydata(self, x, y):
        """Get entity data from the map data"""
        return self.get_upper(self.__data[self.__map_idx][y][x])
     
    def set_entitydata(self, x: int, y: int, val: int) -> None:
        """
        Set entity data to the upper 8 bits on the map data.
        
        self.__data[y][x] & 0x00FF:
            Keeps only the lower 8 bits of the tile, effectively clearing the upper 8 bits.
        
        val & 0xFF00:
            Keeps only the upper 8 bits of val, ensuring the function doesn't accidentally set any lowe bits.
        
        0x00FF: 0000000011111111
        0xFF00: 1111111100000000
        
        """
        self.__data[self.__map_idx][y][x] = (self.__data[self.__map_idx][y][x] & 0x00FF) | (val & 0xFF00)

    def __create_entity(self, xidx: int) -> None:
        """
        Create entity objects based on the map data.

        The function scans a vertical column of tiles at the specified x-index (xidx) across all y-indices (yidx).
        For each tile in that column, it checks the upper 8 bits of the tile's data to determine if an entity should be created.
        If an entity is created, the corresponding map data is cleared (set to 0) to prevent duplicate creation.
        
        Args:
            xidx (int): X axle on the map data
        """
        # Extract the upper 8 bits for the entire column at xidx
        entity_col = [self.get_upper(self.__data[self.__map_idx][yidx][xidx]) for yidx in range(TILE_X)]
        x = xidx * 20
        
        # Scan through each tile in the column
        for yidx, dte in enumerate(entity_col):
            if dte == 0:
                continue
            if dte == 1:
                self.__group.add(Goomba(x, yidx * 20, -2, self.__mario, self))
            elif dte == 2:
                self.__group.add(Koopa(x, yidx * 20, -2, self.__mario, self)) 
            elif dte == 3:  # Mushroom
                self.__group_bg.add(Mushroom(x, yidx * 20, 2, self.__mario, self, oneup=False))  
            elif dte == 4:  # Star
                self.__group_bg.add(Star(x, yidx * 20, 2, self.__mario, self))
            elif dte == 5:  # Coin
                self.__group_bg.add(Coin(x, yidx * 20, 2, self.__mario, self))  
            elif dte == 6:  # 1 UP mushroom
                self.__group_bg.add(Mushroom(x, yidx * 20, 2, self.__mario, self, oneup=True))
            elif dte == 7:  # Static Coin
                self.__group.add(StaticCoin(x, yidx * 20, 2, self.__mario, self))  
            elif dte == 8:  # Goal Flag
                self.__group.add(GoalFlag(x + 10, yidx * 20, 2, self.__mario, self))
            elif dte == 9:  # Castle Flag
                self.__group_bg.add(CastleFlag(x, yidx * 20, 2, self.__mario, self, self.__goal_manager))

            self.set_entitydata(xidx, yidx, 0)

    def draw(self, win: pygame.display, rect: pygame.rect) -> None:
        """
        Draw the visible area of the game map, entities, and HUD on the screen based on Mario's current position.

        This method determines which tiles and entities are visible in the current viewport by calculating the starting
        tile index and horizontal margin based on Mario's position. It handles map scrolling, entity creation, pushed block
        animation, and draws all visible map tiles, background entities, and foreground entities. It also draws the HUD and
        special overlays (game start, pause, game over) depending on Mario's status.

        Parameters:
            win (pygame.display): The Pygame display surface to draw the map and entities onto.
            rect (pygame.rect): The rectangle representing Mario's current position, used to determine the visible portion of the map.

        Returns:
            None
        """
        if self.__mario.status == Status.OPENING:
            self.__hud.draw_game_start(win, self.__world, self.__life_stocks)
        
        elif self.__mario.status == Status.GAMEOVER:
            self.__hud.draw_game_over(win)

        else:
            if self.__mario.status == Status.PAUSE:
                self.__hud.draw_pause(win)

            else:  # If not paused, decrement timer
                self.decrement_timer(self.__mario.status)
            
            margin = 0
        
            # Mario at the left
            if rect.x <= self.NOMOVE_X + self.__nowx:
                startx = self.__nowx // 20
                margin = self.__nowx % 20
            
            # Mario at the mostright
            elif rect.x >= (len(self.__data[self.__map_idx][0]) - 1 - (TILE_X - self.NOMOVE_X // 20)) * 20:
                startx = len(self.__data[self.__map_idx][0]) - TILE_X - 1
                margin = 0
                
            else:
                # Normal scrolling
                startx = rect.x // 20 - self.NOMOVE_X // 20
                margin = rect.x % 20

            # Horizontal offset in Mario's position
            self.__drawmargin = -startx * 20 -margin
            # Update X coordinate on the left edge of the map
            self.__nowx = startx * 20
            
            # Entities appear
            self.__create_entity(startx + TILE_X)

            # pushed block
            delkeys = []
            for key in self.__pushedblocks:
                blockydata = (self.__pushedblocks[key][0] + 1, self.__pushedblocks[key][1] + 1 + self.__pushedblocks[key][0] + 1)
                self.__pushedblocks[key] = blockydata
                if self.__pushedblocks[key][0] >= self.BLOCK_VY:
                    delkeys.append(key)
            for key in delkeys:
                del self.__pushedblocks[key]
            
            # Draw a map
            for y in range(TILE_Y):
                for x in range(startx, startx + TILE_X + 1):
                    map_num = self.get_mapdata(x, y)
                    if map_num > 0 and map_num != self.BLOCK_INVISIBLE:
                        ymargin = 0
                        if (y, x) in self.__pushedblocks:
                            ymargin = self.__pushedblocks[(y, x)][1]
                        win.blit(self.__get_img(map_num), ((x - startx) * 20 - margin, y * 20 + ymargin))

        
        # Draw Heads-up display
        self.__hud.draw(win, self.__score, self.__timer, self.__coin, self.__world)
        
    def fill(self, win: pygame.display) -> None:
        """Fill the background of the window with the color."""
        if self.__mario.status in [Status.OPENING, Status.GAMEOVER]:
            win.fill(self.__bg_color[1])
        else:
            win.fill(self.__bg_color[self.__map_idx])
    
    def __get_img(self, map_num: int) -> pygame.Surface:
        """Get an image"""
        img = self.__imgs[map_num]
        if isinstance(img, tuple):
            img = img[0 if self.__map_idx == 0 else 1]
        return img

    def chk_collision(self, rect: pygame.rect, is_mario: bool = False) -> tuple[int, int] | bool:
        """
        Check for collision between a given rectangular area (rect) and the tiles in the game map. 
        The function checks the 2x2(small Mario) or 2x3(big Mario) tiles surrounding the rectangle.
        If a collision is detected with a pushable block, the function handles the logic for pushing the block.
        If Mario collides with an invisible block, the function returns False to indicate no collision.
    
        Args:
            rect (pygame.rect): Targeted rect to be checked collision

        Returns:
            tuple: Return (x,y) coordinate to indicate a collision, otherwise it returns False
        """
    
        # Convert the top-left position of the rectangle to the corresponding tile indices
        xidx, yidx = rect.x // 20, rect.y // 20  
        
        # Check the 2x2 or 2x3 grid of tiles surrounding the rectangle's top-left corner
        for y in range(2 if rect.height == 20 else 3):
            # Get Mario's both side of rect
            hitleft, hitright = False, False
            blockrectL = pygame.Rect(xidx * 20, (yidx + y) * 20, 20, 20)
            blockrectR = pygame.Rect((xidx + 1) * 20, (yidx + y) * 20, 20, 20)
            
            # Prevent list index out of range
            if (yidx + y) >= len(self.__data[self.__map_idx]) or (xidx + 1) >= len(self.__data[self.__map_idx][0]):
                return
            
            # Collision check            
            if (self.get_mapdata(xidx, yidx + y) and 
                not self.is_goal_block(xidx, yidx + y) and rect.colliderect(blockrectL)):
                hitleft = True
            if (self.get_mapdata(xidx + 1, yidx + y) and 
                not self.is_goal_block(xidx + 1, yidx + y) and rect.colliderect(blockrectR)):
                hitright = True
            
            # Make sure which block is pushed considering the Mario location
            x = 0
            if hitleft and hitright:
                if rect.x < blockrectL.centerx:
                    blockrect = blockrectL
                else:
                    blockrect = blockrectR
                    x = 1
            elif hitleft:
                blockrect = blockrectL
            elif hitright:
                blockrect = blockrectR
                x = 1
            else:
                continue
                # If nothing collides, the function returns.

            if is_mario:
                map_id = self.get_mapdata(xidx + x, yidx + y)
                # Block is being pushed, and prevent jumping on the invisible block
                if (map_id in self.PUSHED_BLOCKS and rect.y > blockrect.y and self.__mario.vy < 0 and
                    rect.centery - blockrect.centery > 5):
                    
                    if abs(blockrect.centerx - rect.centerx) < 10:
                        # Crush a block
                        if map_id == self.BLOCK_NORMAL and self.__mario.isbig:
                            self.set_mapdata(xidx + x, yidx + y, 0)
                            
                            # Add animation for a crushed block
                            bx, by = (xidx + x) * 20, (yidx + y) * 20
                            self.__group.add(BrokenBlock(bx, by, 3, -5, self.__mario, self))
                            self.__group.add(BrokenBlock(bx, by, -3, -5, self.__mario, self))
                            self.__group.add(BrokenBlock(bx, by, 3, 5, self.__mario, self))
                            self.__group.add(BrokenBlock(bx, by, -3, 5, self.__mario, self))
                            
                        else:
                            self.__pushedblocks[(yidx + y, xidx + x)] = (-1 * self.BLOCK_VY, 0)
                    
                            # Change Question/Invisible 1Up/Normal Star blocks to Panel
                            if map_id in [self.BLOCK_QUESTION, self.BLOCK_INVISIBLE, self.BLOCK_STAR] :
                                self.set_mapdata(xidx + x, yidx + y, self.BLOCK_PANEL)
                
                elif map_id == self.BLOCK_INVISIBLE:
                    return False
                                
            return (yidx + y, xidx + x)
        return False

    def get_drawx(self, rect: pygame.rect) -> int:
        """X coordinate to draw Mario on the map"""
        # Mario at the left
        if rect.x < self.NOMOVE_X + self.__nowx:
            x = rect.x - self.__nowx
        
        # Mario at the mostright
        elif rect.x >= (len(self.__data[self.__map_idx][0]) - 1 - (TILE_X - self.NOMOVE_X // 20)) * 20:
            x = rect.x - (len(self.__data[self.__map_idx][0]) - 1 - (TILE_X - self.NOMOVE_X // 20)) * 20 + self.NOMOVE_X
        
        else:
            # Keep Mario at the center
            x = self.NOMOVE_X
        return x

    def get_drawxentity(self, rect: pygame.rect) -> int:
        """
        Calculate the correct X coordinate to draw entity on the screen based on the map's scrolling position.
        This function accounts for the scrolling margin and adjusts the entity's horizontal position accordingly.
        The position is calculated relative to the current map view, ensuring that enemies are drawn correctly 
        in the viewport and move with the map.

        Args:
            rect (pygame.rect): The rectangle representing the entity's current position on the map.

        Returns:
            int: The calculated x-coordinate where the entity should be drawn on the screen.
        
        """
        return rect.x + self.__drawmargin
    
    def ispushedblock(self, yx: tuple[int, int]) -> bool: 
        """Ensure if it's pushed or not."""
        return yx in self.__pushedblocks
    
    def change_map(self, next_mapdata) -> None:
        """
        Change the map with deleting entities and drawing entites.
        """
        map_idx, xidx = next_mapdata[:2]
        self.__map_idx = map_idx
        self.__nowx = xidx * 20 - self.NOMOVE_X

        if self.__nowx < 0:
            self.__nowx = 0
        
        # Mario at the right
        elif self.__nowx > (len(self.__data[self.__map_idx][0]) - 1 - (TILE_X - self.NOMOVE_X // 20)) * 20:
            self.__nowx = (len(self.__data[self.__map_idx][0]) - 1 - (TILE_X - self.NOMOVE_X // 20)) * 20

        # Delete entities
        for entity in self.__group.sprites():
            if not isinstance(entity, Mario):
                entity.status = Status.DEAD

        for entity in self.__group_bg.sprites():
            entity.status = Status.DEAD
        
        # Draw entity
        for xidx in range(self.__nowx // 20, self.__nowx // 20 + TILE_X):
            self.__create_entity(xidx)

    def add_score(self, value) -> None:
        """Add score"""
        self.__score += value
        
    def add_coin(self) -> None:
        """Increment a coin"""
        self.__coin += 1
    
    def decrement_timer(self, status: int) -> None:
        """Decrease timer"""
        if status != Status.GOAL:     
            # Decrease timer
            self.__timer -= 0.033
            if self.__timer <= 0:
                self.__timer = 0
    
    def add_timer_score(self) -> bool:
        """Add 100 score per a second at the goal."""
        if self.__timer > 0:
            self.add_score(100)
            self.__timer -= 1
            return False
        
        elif self.__timer <= 0:
            self.__timer = 0
            return True
    
    def decrement_life_stocks(self):
        """Decrement life stocks and change Mario status to GAMEOVER if the life stock becomes zero."""
        self.__life_stocks -= 1
        if self.__life_stocks == 0:
            # Change Mario status to GAMEOVER
            self.__mario.status = Status.GAMEOVER
    
    def increment_life_stocks(self) -> None:
        """Increment life stocks when it get a 1 up mushroom."""
        self.__life_stocks += 1
        

class Mario(pygame.sprite.Sprite):
    """Mario class"""
    
    WALK_ANIME_IDX = [0, 0, 1, 1, 2, 2]
    WALK_ANIME_BIG_IDX = [6, 6, 7, 7, 8, 8]
    WALK_ANIME_FIRE_IDX = [10, 10, 11, 11, 12, 12]
    MAX_SPEED_X: int = 5
    ACC_SPEED_X: float = 0.25
    DASH_SPEED_X: int = 8
    MAX_JUMP_Y = 7
    DASH_JUMP_Y = 10
    
    def __init__(self, map, group):
        pygame.sprite.Sprite.__init__(self)
        
        # Load mario images
        self.__imgs: list = [
            pygame.image.load('./img/mario_1.jpg'),
            pygame.image.load('./img/mario_2.jpg'),
            pygame.image.load('./img/mario_3.jpg'),
            pygame.image.load('./img/mario_death.jpg'),
            pygame.image.load('./img/mario_jump.jpg'),
            pygame.image.load('./img/mario_middle.jpg'),
            pygame.image.load('./img/mario_big_1.jpg'),
            pygame.image.load('./img/mario_big_2.jpg'),
            pygame.image.load('./img/mario_big_3.jpg'),
            pygame.image.load('./img/mario_big_jump.jpg'),
            pygame.image.load('./img/mario_fire_1.jpg'),
            pygame.image.load('./img/mario_fire_2.jpg'),
            pygame.image.load('./img/mario_fire_3.jpg'),
            pygame.image.load('./img/mario_fire_jump.jpg'),
            pygame.image.load('./img/mario_sit.jpg'),
            pygame.image.load('./img/mario_fire_sit.jpg'),
            # TODO: Add images of falling down to the goal pole for the goal animation
            ]
        
        self.image = self.__imgs[0]
        
        # The coordinate for map and the location of Mario are different.
        # Mario location coordinate        
        self.__rawrect = pygame.Rect(30, 220, 20, 20)
        # Mario coordinate for Map
        self.rect = self.__rawrect
        
        # Get a map
        self.__map: Map = map

        # Set Mario to Map
        self.__map.mario = self

        # Set a group for Sprite
        self.__group = group
        
        # Common initialization
        self.__common_init()
    
    def __common_init(self):
        self.image = self.__imgs[0]

        # Flag for Mario direction
        self.__isleft: bool = False
        
        # idx for walking animation
        self.__walkidx: int = 0

        # Y axle move distance
        self.__vy: int = 0
        
        # X axle move distance 
        self.__vx: float = 0
        
        # Flag for dash
        self.__isdash = False
        
        # Cumulative ascent distance
        self.__ay: int = 0
        
        # Judge if Mario is on ground
        self.__on_ground: bool = False

        # Status
        self.__status = Status.OPENING
        
        # Array for Koopa kick/fire ball
        self._arrlies: list = []

        # Counter for crushing enemies continuously
        self.__continuous_counter : int = 0
        
        # Anime counter
        self.__animecounter: int = 0
        
        # Growing counter
        self.__growcounter: int = 0
        
        # Grown Mario
        self.__isbig: bool = False
        
        # Invisible
        self.__isinvisible: bool = False
        self.__invisiblecounter: int = 90

        # Warping
        self.__next_data: tuple = None
        self.__warpcounter: int = 0
        
        # Star Mario
        self.__hasstar: bool = False
        
        # Fire Mario
        self.__isfire: bool = False
        
        # Sit Mario
        self.__issit: bool = False
    
    def init_dead(self) -> pygame.sprite:
        """Initialize when Mario is dead."""
        group, group_bg = self.__map.init_dead()
        self.__group = group
        self.__rawrect = pygame.Rect(30, 220, 20, 20)
        self.__common_init()
        return group, group_bg
    
    @property
    def vy(self):
        return self.__vy
    
    @vy.setter
    def vy(self, value):
        self.__vy = value
        
    @property
    def status(self):
        return self.__status
    
    @status.setter
    def status(self, value):
        self.__status = value
    
    @property
    def rawrect(self):
        return self.__rawrect
    
    @property
    def arrlies(self):
        return self._arrlies
    
    @property
    def isbig(self):
        return self.__isbig
    
    @property
    def isinvisible(self):
        return self.__isinvisible
    
    @isinvisible.setter
    def isinvisible(self, value):
        self.__isinvisible = value

    @property
    def invisiblecounter(self):
        return self.__invisiblecounter

    @invisiblecounter.setter
    def invisiblecounter(self, value):
        self.__invisiblecounter = value

    @property
    def hasstar(self):
        return self.__hasstar
    
    @hasstar.setter
    def hasstar(self, value):
        self.__hasstar = value

    @property
    def isfire(self):
        return self.__isfire
    
    @isfire.setter
    def isfire(self, value):
        self.__isfire = value
    
    @property
    def continuous_counter(self):
        return self.__continuous_counter
    
    @continuous_counter.setter
    def continuous_counter(self, value):
        self.__continuous_counter = value
    
    def draw(self, win):
        win.blit(self.image, self.rect)
    
    def __change_pixel(self, n, image):
        pixels = pygame.surfarray.pixels3d(image)
        if n == 0:
            pixels[..., [0, 1, 2]] = pixels[..., [1, 2, 0]]
        elif n== 1:
            pixels[..., [0, 1, 2]] = pixels[..., [2, 1, 0]]
        elif n == 2:
            pixels[..., [0, 1, 2]] = pixels[..., [0, 2, 1]]
    
    def __get_image(self):
        # Image for sitting
        if self.__issit and self.__isbig:
            imageidx = 14 if not self.__isfire else 15
            
        # Choose Mario image for walking animation
        elif self.__vx == 0:
            if not self.__isfire:
                imageidx = 0 if not self.__isbig else 6 
            else:
                imageidx = 10
        else:
            if not self.__isfire:
                imageidx = self.WALK_ANIME_IDX[self.__walkidx % 6] if not self.__isbig else self.WALK_ANIME_BIG_IDX[self.__walkidx % 6]
            else:
                imageidx = self.WALK_ANIME_FIRE_IDX[self.__walkidx % 6]
        # Choose the jump mario image
        if not self.__on_ground:
            if not self.__isfire:
                imageidx = 4 if not self.__isbig else 9
            else:
                imageidx = 13
            
        # Change the image direction if its direction is left
        return pygame.transform.flip(self.__imgs[imageidx], self.__isleft, False)

    def update(self):
        if self.__status == Status.DEAD:
            pass
        
        # Draw game start
        if self.__status == Status.OPENING:
            # Put the mario at the center of the game start window
            self.rect = pygame.Rect(130, 140, 20, 20)
            self.__game_start()
            return
        
        # Draw game over
        if self.__status == Status.GAMEOVER:
            self.__game_over()
            return
        
        # When timer is 0, game ends except game clear
        if self.__map.timer == 0 and not self.__status in [Status.GOAL, Status.CLEAR]:
            self.__status = Status.DEADING
            
        if self.__status == Status.DEADING:
            self.image = self.__imgs[3]
            self.__deading()
            self.rect = pygame.Rect(self.__map.get_drawx(self.__rawrect), self.__rawrect.y, self.__rawrect.width, self.__rawrect.height)
            return
        
        # Fall handling
        if self.__rawrect.y > H:
            self.__status = Status.DEAD
            
            # Decrement life stocks
            self.__map.decrement_life_stocks()
            return
        
        # Mario gets a mushroom
        if self.__status == Status.GROWING:            
            self.__growing()
            self.rect = pygame.Rect(self.__map.get_drawx(self.__rawrect), self.__rawrect.y, self.__rawrect.width, self.__rawrect.height)
            return
        
        # Mario becomes small
        if self.__status == Status.SHRINKING:
            self.__shrinking()
            self.image.set_alpha(128) 
            self.rect = pygame.Rect(self.__map.get_drawx(self.__rawrect), self.__rawrect.y, self.__rawrect.width, self.__rawrect.height)
            return
        
        # Warping
        if self.__status in (Status.ENTERING, Status.APPEARING):
            self.__warping(is_entering=True if self.__status == Status.ENTERING else False)
            self.rect = pygame.Rect(self.__map.get_drawx(self.__rawrect), self.__rawrect.y, self.__rawrect.width, self.__rawrect.height)
            return
        
        # Game is paused
        # "p" is pushed -> Mario status changes from NORMAL to PAUSE and vice versa
        if self.__status == Status.PAUSE:
            self.image = self.__get_image()
            self.rect = pygame.Rect(self.__map.get_drawx(self.__rawrect), self.__rawrect.y, self.__rawrect.width, self.__rawrect.height)
            return
            
        # Goal process
        if self.__status == Status.GOAL:
            # Goal animation does not end
            # if not self.__goal():
            self.image = self.__get_image()
            self.rect = pygame.Rect(self.__map.get_drawx(self.__rawrect), self.__rawrect.y, self.__rawrect.width, self.__rawrect.height)
            return
        
        else:
            # Mario movement processes except GOAL status
            # Get key status
            keys = pygame.key.get_pressed()
            
            # Not move when sitting
            if not keys[pygame.K_DOWN]:
                if keys[pygame.K_RIGHT]:
                    self.__right()
                    
                if keys[pygame.K_LEFT]:
                    self.__left()
            
            if keys[pygame.K_SPACE]:
                self.__jump()
            else:
                # When Space isn't inputed
                if self.__vy <= -5:
                    # Don't fall down imediately
                    self.__vy = -3
                if self.__vy >= 0:
                    # Status is Normal when falling down
                    self.__status = Status.NORMAL
            
            # If Mario sits or not
            if keys[pygame.K_DOWN]:
                if not self.__issit and self.__isbig:
                    self.__rawrect.height = 30
                    self.__issit = True
            else:
                if self.__issit and self.__isbig:
                    self.__rawrect.height = 40
                self.__issit = False

            # Dash with left shift
            self.__isdash = keys[pygame.K_LSHIFT]
            
            if self.__vx != 0:
                if (not keys[pygame.K_LEFT] and not keys[pygame.K_RIGHT]) or keys[pygame.K_DOWN]:
                    self.__stop()
            
            # Warp
            self.warp(keys)
                        
            # Move for Y axle
            # if not self.__on_ground:
            self.__vy += 1
            self.__rawrect.y += self.__vy
                    
            # Judge hitbox
            if self.__map.chk_collision(self.__rawrect, is_mario=True):
                # If Mario is moving upward, it lets him go downward
                # vy is bigger than 0 -> 1 to go upward
                self.__rawrect.y = ((self.__rawrect.y // 20 + (1 if self.__vy < 0 else 0)) * 20)
                
                # Adjustment when Mario is sitting
                self.__rawrect.y += 10 if self.__issit else 0
                
                if self.__vy > 0:
                    self.__on_ground = True
                    self.__vy = 0
                    
                    # Initialize continuous_counter
                    self.__continuous_counter = 0
                        
                else:
                    self.__vy = 1
            
            # End invisible state
            if self.__isinvisible:
                self.__invisiblecounter -= 1
                if self.__invisiblecounter == 0:
                    self.__isinvisible = False
                    # initialization
                    self.__invisiblecounter = 90
            
            # Get the image
            self.image = self.__get_image()
        
        if self.__isinvisible:
            # Blinking for a star mario
            if self.__hasstar:
                
                if self.__invisiblecounter < 60:
                    # Slowly blinking for the last 2 seconds
                    n = self.__invisiblecounter % 16 // 4
                else:
                    n = self.__invisiblecounter % 4
                self.__change_pixel(n, self.image)

            else:
                # Set invisible Mario
                self.image.set_alpha(128)
        else:
            self.image.set_alpha(255)
                
        # Update rect for Splite
        self.rect = pygame.Rect(self.__map.get_drawx(self.__rawrect), self.__rawrect.y, self.__rawrect.width, self.__rawrect.height)
            
    def move(self):
        self.__walkidx += 1
        
        # Prevent to move to the outside of the window
        if self.__rawrect.x < self.__map.nowx:
            self.__rawrect.x = self.__map.nowx
        
        # Collision check
        if self.__map.chk_collision(self.__rawrect):
            self.__rawrect.x = (self.__rawrect.x // 20 + (1 if self.__isleft else 0)) * 20     
    
    def __right(self):
        if not self.__isdash:
            if self.__vx > self.MAX_SPEED_X:
                self.__vx -= self.ACC_SPEED_X
            else:
                self.__vx = (self.__vx + self.ACC_SPEED_X) if self.__vx < self.MAX_SPEED_X else self.MAX_SPEED_X
        else:
            # Dash
            self.__vx = (self.__vx + self.ACC_SPEED_X) if self.__vx < self.DASH_SPEED_X else self.DASH_SPEED_X
        
        # Cancel law of inertia when changing the direction.
        if self.__isleft:
            self.__vx = 0
        
        self.__rawrect.x += self.__vx
        self.__isleft = False
        self.move()

    def __left(self):
        if not self.__isdash:
            if self.__vx < -1 * self.MAX_SPEED_X:
                self.__vx += self.ACC_SPEED_X
            else:
                self.__vx = (self.__vx - self.ACC_SPEED_X) if self.__vx > -1 * self.MAX_SPEED_X else -1 * self.MAX_SPEED_X
        else:
            # Dash
            self.__vx = (self.__vx - self.ACC_SPEED_X) if self.__vx > -1 *  self.DASH_SPEED_X else -1 * self.DASH_SPEED_X
        
        # Cancel law of inertia when changing the direction.
        if not self.__isleft:
            self.__vx = 0
        
        self.__rawrect.x += self.__vx
        self.__isleft = True
        self.move()
        
    def __jump(self):
        # If Mario is on ground, he can jump
        if self.__on_ground:
            if abs(self.__vx) == self.DASH_SPEED_X:
                # Dash jump
                self.__vy -= self.DASH_JUMP_Y
            else:
                self.__vy -= self.MAX_JUMP_Y  
            # self.__vy = -7
            self.__ay = 0
            self.__on_ground = False
        
        if self.__vy < 0:
            # Keep jumping until ay reaches 65
            if self.__ay < 65:
                self.__vy -= 1
                self.__ay -= self.__vy
    
    def __stop(self):
        self.__vx = self.__vx + self.ACC_SPEED_X * (1 if self.__isleft else -1)
        self.__rawrect.x += self.__vx
        
        # Prevent to move to the outside of the window
        if self.__rawrect.x < self.__map.nowx:
            self.__rawrect.x = self.__map.nowx
        
        # Collision check to prevent going into blocks by inertia 
        if self.__map.chk_collision(self.__rawrect):
            self.__rawrect.x = (self.__rawrect.x // 20 + (1 if self.__isleft else 0)) * 20
    
    def __deading(self):
        if self.__animecounter == 0:
            self.__vy = -10
        
        if self.__animecounter > 10:
            self.__vy += 1
            self.__rawrect.y += self.__vy
        
        if self.__rawrect.y > H + 20:
            self.__status = Status.DEAD
            
            # Decrement life stocks
            self.__map.decrement_life_stocks()
            return
        self.__animecounter += 1
    
    def __growing(self):
        if self.__isfire:
            if self.__growcounter == 30:
                self.__status = Status.NORMAL
                self.__growcounter = 0
                return
            self.image = self.__get_image()
            self.__change_pixel(self.__growcounter % 8 //2, self.image)
            
        else:
            if self.__growcounter == 0:
                self.image = self.__imgs[6]
                self.__rawrect.y -= 20
            
            elif self.__growcounter == 6:
                self.image = self.__imgs[5]
                
            elif self.__growcounter == 8:
                self.image = self.__imgs[0]
                self.__rawrect.y += 20
                        
            elif self.__growcounter == 10:
                self.image = self.__imgs[6]
                self.__rawrect.y -= 20
                        
            elif self.__growcounter == 12:
                self.image = self.__imgs[5]
                
            elif self.__growcounter == 14:
                self.image = self.__imgs[0]
                self.__rawrect.y += 20
                        
            elif self.__growcounter == 16:
                self.image = self.__imgs[6]
                self.__rawrect.y -= 20
                
            elif self.__growcounter == 18:
                self.image = self.__imgs[5]

            elif self.__growcounter == 20:
                self.image = self.__imgs[6]
                self.__rawrect.y -= 20  # to offset +=10
                self.__rawrect.height = 40
                self.__isbig = True
                self.__status = Status.NORMAL
                # Initialize counter
                self.__growcounter = 0
                        
        self.__growcounter += 1
    
    def __shrinking(self):
        if self.__growcounter == 0:
            self.image = self.__imgs[0]
            self.__rawrect.y += 20
        
        elif self.__growcounter == 6:
            self.image = self.__imgs[5]
            
        elif self.__growcounter == 8:
            self.image = self.__imgs[6]
                     
        elif self.__growcounter == 10:
            self.image = self.__imgs[0]
                     
        elif self.__growcounter == 12:
            self.image = self.__imgs[5]
            
        elif self.__growcounter == 14:
            self.image = self.__imgs[6]
                     
        elif self.__growcounter == 16:
            self.image = self.__imgs[0]
            
        elif self.__growcounter == 18:
            self.image = self.__imgs[5]

        elif self.__growcounter == 20:
            self.image = self.__imgs[0]
            # self.__rawrect.y += 20  # to offset +=10
            self.__rawrect.height = 20
            self.__isbig = False
            self.__status = Status.NORMAL
            # Initialize counter
            self.__growcounter = 0
            
            self.__isinvisible = True
        self.__growcounter += 1
    
    def slide_down_pole(self):
        self.__rawrect.y += GOAL_FALL_SPEED
        if self.__rawrect.y > GOAL_BOTTOM_Y - (20 if self.__isbig else 0):
            self.__rawrect.y = GOAL_BOTTOM_Y - (20 if self.__isbig else 0)
    
    def change_side(self) -> None:
        self.__rawrect.x += 40
        self.__rawrect.y = 240 - (20 if self.__isbig else 0)

        # for walk animation
        self.__walkidx = 0
        self.__on_ground = True
        
    def walk_to_castle(self) -> None:
        self.__right()
    
    def enter_castle(self) -> None:
        # TODO: Mario doesn't become invisible if it's Fire Mario.
        self.__isinvisible = True
        self.__vx = 0
        
    def fire(self):
        """Create Fire objects, limiting only two objects."""
        firecount = 0
        for entity in self.__group.sprites():
            if isinstance(entity, Fire):
                firecount += 1
        
        if firecount == 2:
            return
        
        # Create and add Fire ojects
        fire = Fire(self.__rawrect.x, self.__rawrect.y + 10, -5 if self.__isleft else 5, self, self.__map)
        self.__group.add(fire)
        self.__map.sound.play_sound_asnync(self.__map.sound.play_fire)
        
        # Add if a fireball hits enemies
        self._arrlies.append(fire)
    
    def warp(self, keys: pygame.key) -> None:
        """Proceed with the necessary processes for warp if the conditions are met."""

        # Get the current location
        xidx, yidx = self.__rawrect.x // 20, self.__rawrect.y // 20

        # Ensure about the warp location and key input
        if (xidx, yidx) in self.__map.warp_info:
            self.__next_data = self.__map.warp_info[(xidx, yidx)]
            # Make sure if the key input matches or not
            if self.__next_data[3] == 1 and keys[pygame.K_DOWN]:
                self.__status = Status.ENTERING
            if  self.__next_data[3] == 2 and keys[pygame.K_RIGHT]:
                self.__status = Status.ENTERING
            
    def __warping(self, is_entering: bool) -> None:
        """
        Deal with warping animation for both entering a pipe and appearing from a pipe.

        Args:
            is_entering (bool): True if it depict an animation of entering a pipe.
        """
        if self.__warpcounter == 10:
            self.__warpcounter = 0
            self.__vx = 0
            self.__vy = 0
            self.__rawrect.x = self.__next_data[1] * 20
            self.__rawrect.y = (self.__next_data[2] * 20) - (20 if not is_entering and self.__isbig else 0)
            self.__map.change_map(self.__next_data)
            if self.__status == Status.APPEARING:
                self.__status = Status.NORMAL
            else:
                self.__status = Status.APPEARING if self.__next_data[4] else Status.NORMAL
                
        else:
            idx = 3 if is_entering else 4
            # To down
            if self.__next_data[idx] == 1:
                self.__rawrect.y += 2
                
            # To right
            if self.__next_data[idx] == 2:
                self.__rawrect.x += 2
                self.__walkidx = 0

            # To up
            if self.__next_data[idx] == 3:
                self.__rawrect.y -= 2           

            self.__warpcounter += 1

    def __game_start(self) -> None:
        if self.__animecounter >= 60:
            self.__status = Status.NORMAL
            self.__animecounter = 0
            return
        
        self.__animecounter += 1
    
    def __game_over(self) -> None:
        if self.__animecounter >= 180:
           self.__animecounter = 0
           self.__status = Status.INIT
           return
        
        self.__animecounter += 1


class Entity(pygame.sprite.Sprite):
    def __init__(self, x, y, dir, mario, map):
        pygame.sprite.Sprite.__init__(self)
                
        # The coordinate for map and the location of Mario are different.
        # Entity location coordinate        
        self._rawrect = pygame.Rect(x, y, 20, 20)
        # Entity coordinate for Map
        self.rect = self._rawrect
        
        # Get a map
        self._map: Map = map
        
        # X axle move distance
        self._dir: int = dir
        self._walkidx: int = 0
        
        # Y axle move
        self._vy: int = 0
        
        # Get mario 
        self._mario: Mario = mario

        # Status
        self._status = Status.NORMAL

        # Counter for collapse
        self._collapsecount: int = 0

    @property
    def status(self):
        """Get the status"""
        return self._status
    
    @status.setter
    def status(self, value):
        self._status = value
    
    @property
    def rawrect(self):
        return self._rawrect
    
    @property
    def dir(self):
        return self._dir
        
    def kickHit(self) -> None:
        """
        TODO: Update Docstring and modify the function name
        Judge if Koopa kick hits or not. If it hits, the status is changed to FLYING.
        """
        # Koopa kick flying
        for marioarrly in self._mario.arrlies:
            if self._rawrect.colliderect(marioarrly.rawrect):
                self._status = Status.FLYING
                    
                # Decide the direction to fly
                self._dir = 3 if self._rawrect.centerx > marioarrly.rawrect.centerx else -3
                
                # Remove a fire ball
                if isinstance(marioarrly, Fire):
                    marioarrly.status = Status.DEADING
                    self._mario.arrlies.remove(marioarrly)
                    
                    # Display score for Fira ball
                    self._map.group.add(Number(self.rect.x, self.rect.y, SCORE_ARRAY[1]))
                    self._map.add_score(SCORE_ARRAY[1])
                    
                elif isinstance(marioarrly, Koopa):
                    # Display score for Koopa kick
                    score = SCORE_ARRAY[self._mario.continuous_counter] if not self._mario.continuous_counter >= len(SCORE_ARRAY) else ONEUP_SCORE
                    self._map.group.add(Number(self.rect.x, self.rect.y, score))
                    self._map.add_score(score)
                    self._mario.continuous_counter += 1
                
                self._vy = -8
    
    def flying(self) -> None:
        """
        Let entity fly after Koopa kick hits and change the status to DEAD
        """
        self._rawrect.x += self._dir
        self._rawrect.y += self._vy
        self._vy += 1
            
        if self._rawrect.y >= H:
            # Disapear
            self._status = Status.DEAD
    
    def _handle_mario_hit(self) -> None:
        # If Mario hits Koopa
        if self._mario.vy > 0:
            # Squash
            self._status = Status.DEADING
                                
            # Mario jump action
            self._mario.status = Status.TREADING
            self._mario.vy = -5
            # Display score
            score = SCORE_ARRAY[self._mario.continuous_counter] if not self._mario.continuous_counter >= len(SCORE_ARRAY) else ONEUP_SCORE
            self._map.group.add(Number(self.rect.x, self.rect.y, score))
            self._map.add_score(score)
            self._mario.continuous_counter += 1
        else:
            # If Mario is invisible, then return.
            if self._mario.isinvisible and not self._mario.hasstar:
                return
            
            if self._mario.hasstar:
                self._status = Status.FLYING
                # Display score to be defeated by Star Mario
                self._map.group.add(Number(self.rect.x, self.rect.y, SCORE_ARRAY[1]))
                self._map.add_score(SCORE_ARRAY[1])
                return
            
            if self._mario.status != Status.TREADING:
                if self._mario.isbig:
                    self._mario.status = Status.SHRINKING
                    if self._mario.isfire:
                        self._mario.isfire = False
                else:
                    self._mario.status = Status.DEADING
            

class Mushroom(Entity):    
    def __init__(self, x, y, dir, mario, map, oneup=False):
        self.__imgs = [
            pygame.image.load('./img/kinoko.jpg'),
            pygame.image.load('./img/fireflower.jpg'),
            pygame.image.load('./img/1upkinoko.jpg'),
            ]
        self.image = self.__imgs[0]
        self._rawrect = pygame.Rect(x, y, 20, 20)
        
        self.__isflower: bool = False
        self.__isoneup: bool = oneup
        
        super().__init__(x, y, dir, mario, map)
    
    def update(self):
        # Not update if Mario is dead or growing or shrinking, or Game is paused
        if self._mario.status in [Status.DEADING, Status.GROWING, Status.SHRINKING, Status.PAUSE]:
            return
        
        # If Mario hit Mushroom box
        if self._status == Status.NORMAL:
            x, y = self._rawrect.x // 20, self._rawrect.y // 20
            if self._map.ispushedblock((y, x)):
                self._map.sound.play_sound_asnync(self._map.sound.play_item)
                self._status = Status.TREADING
                self._rawrect.y -= 5
                self.__isflower = not self.__isoneup and self._mario.isbig
            self.image.set_alpha(0)
        
        # Fall handling
        if self._rawrect.y > H:
            self._status = Status.DEAD
        
        # Mushroom is showing up
        elif self._status == Status.TREADING:
            self._walkidx += 1
            if self._walkidx == 4:
                self.image.set_alpha(255)
                
            if self._walkidx <= 15:
                self._rawrect.y -= 1
            # Once mushroom appears, then it stops
            if self._walkidx == 18:
                self._status = Status.FLYING
        
        # Mushroom is moving horizontally
        elif self._status == Status.FLYING:
            # If Mario is big, it plays as a flower, if not mushroom.
            if not self.__isflower:
                # X axle move
                self._rawrect.x += self._dir
                
                # X axle collision check
                if self._map.chk_collision(self._rawrect):
                    self._rawrect.x = (self._rawrect.x // 20 + (1 if self._dir < 0 else 0)) * 20
                    self._dir *= -1

                # Y axle move
                self._vy += 1
                self._rawrect.y += self._vy
                    
                # Y axle collision check
                if self._map.chk_collision(self._rawrect):
                    self._rawrect.y = (self._rawrect.y // 20 + (1 if self._vy < 0 else 0)) * 20
                                    
                    if self._vy > 0:
                        self._vy = 0
                    else:
                        # jump
                        self._vy = 1
            
            # Collision check with Mario
            if self._rawrect.colliderect(self._mario.rawrect):
                if self.__isoneup:
                    self._map.sound.play_sound_asnync(self._map.sound.play_oneup)
                    self._map.group.add(Number(self.rect.x, self.rect.y, ONEUP_SCORE))
                    self._status = Status.DEAD
                    # increment life stocks
                    self._map.increment_life_stocks()
                    # TODO: Add 1UP to self._map.value

                else:
                    if not self._mario.isfire:                    
                        self._mario.status = Status.GROWING
                        self._map.sound.play_sound_asnync(self._map.sound.play_power)
                        if self.__isflower:
                            self._mario.isfire = True
                    self._map.group.add(Number(self.rect.x, self.rect.y, 1000))
                    self._map.add_score(1000)
                    self._status = Status.DEAD
                            
        self.image = self.__imgs[2 if self.__isoneup else 0 if not self._mario.isbig else 1]
        self.rect = pygame.Rect(self._map.get_drawxentity(self._rawrect), self._rawrect.y, self._rawrect.width, self._rawrect.height)
        

class Koopa(Entity):
    WALK_SPEED = 6
    WALK_ANIME_IDX = [0, 0, 0, 1, 1, 1]
    
    def __init__(self, x, y, dir, mario, map):
            # Load goomba images        
            self.__imgs: list = [
                pygame.image.load('./img/Koopa_1.jpg'),
                pygame.image.load('./img/Koopa_2.jpg'),
                pygame.image.load('./img/Koopa_death.jpg'),
                pygame.image.load('./img/Koopa_reborn.jpg'),
            ]

            self.image = self.__imgs[0]
            
            super().__init__(x, y, dir, mario, map)
        
    def update(self):
        # Not update if Mario is dead or growing or shrinking or Game is paused 
        if self._mario.status in [Status.DEADING, Status.GROWING, Status.SHRINKING, Status.PAUSE]:
            return
        
        if self._status == Status.DEADING:
            self.image = self.__imgs[2]
            # Update rect for Splite
            self.rect = pygame.Rect(self._map.get_drawxentity(self._rawrect), self._rawrect.y, self._rawrect.width, self._rawrect.height)
            self._collapsecount += 1
            
            if self._collapsecount >= 60:
                # Add an animation for reborn
                self.image = self.__imgs[3]
                
            # collapsecount is set 100 temporarily
            if self._collapsecount == 100:
                self._status = Status.NORMAL
                self._collapsecount = 0
                
                # move again after reborn
                self._dir = 2 if self._dir > 0 else -2
                
                # Remove Koopa from Mario's arrlies list if reborn
                for _ in range(len(self._mario.arrlies)):
                    if self._rawrect in self._mario.arrlies:
                       self._mario.arrlies.remove(self._rawrect)

        # Flying if Koopa kick hits goomba
        if self._status == Status.FLYING:
            super().flying()
            # self._rect = self._map.get_drawxenemy(self._rawrect), self._rawrect.top
            self.image = pygame.transform.flip(self.__imgs[0], False, True)
        
        if self._status == Status.NORMAL:
            # Koopa kick flying
            super().kickHit()

        if self._status == Status.NORMAL or self._status == Status.SLIDING:
            # X axle move
            self._rawrect.x += self._dir
            
            # X axle collision check
            if self._map.chk_collision(self._rawrect):
                self._rawrect.x = (self._rawrect.x // 20 + (1 if self._dir < 0 else 0)) * 20
                self._dir *= -1
                    
            # Y axle move
            self._vy += 1
            self._rawrect.y += self._vy
                
            # Y axle collision check
            if yx := self._map.chk_collision(self._rawrect):
                self._rawrect.y = (self._rawrect.y // 20 + (1 if self._vy < 0 else 0)) * 20
                # If a block is pushedW
                if self._map.ispushedblock(yx):
                    self._status = Status.FLYING
                    self._dir = 3 if self._rawrect.centerx > self._mario.rawrect.centerx else -3
                    self._vy = -8
                    
                    self.image = pygame.transform.flip(self.__imgs[0], False, True)
                    # Update rect for Splite
                    self.rect = pygame.Rect(self._map.get_drawxentity(self._rawrect), self._rawrect.y, self._rawrect.width, self._rawrect.height)
                    return

                if self._vy > 0:
                    self._vy = 0
                else:
                    # jump
                    self._vy = 1

            if self._status == Status.NORMAL:
                self._walkidx += 1
                if self._walkidx == self.WALK_SPEED:
                    self._walkidx = 0
                    self.image = pygame.transform.flip(self.__imgs[self._walkidx < self.WALK_SPEED // 2], self._dir > 0, False)
            elif self._status == Status.SLIDING:
                # Image for Koopa kick
                self.image = self.__imgs[2]

        if self._status == Status.NORMAL or self._status == Status.SLIDING or self._status == Status.DEADING:
            # Collision check with Mario
            if self._rawrect.colliderect(self._mario.rawrect):
                    
                if self._status == Status.NORMAL:
                    super()._handle_mario_hit()
                                            
                elif self._status == Status.DEADING:
                    self._status = Status.SLIDING
                    # Koopa kick when Mario hits deading Koopa
                    if self._mario.vy > 0:
                        self._mario.status = Status.TREADING
                        self._mario.vy = -5
                    
                    # Decide the direction to slide
                    self._dir = 6 if self._mario.rawrect.centerx < self._rawrect.centerx else -6
                    
                    # add kicked Koopa rawrect into array
                    self._mario.arrlies.append(self)
                    
                elif self._status == Status.SLIDING:
                    super()._handle_mario_hit()
                                    
        # Update rect for Splite
        self.rect = pygame.Rect(self._map.get_drawxentity(self._rawrect), self._rawrect.y, self._rawrect.width, self._rawrect.height)


class Goomba(Entity):
    WALK_SPEED = 6
    
    def __init__(self, x, y, dir, mario, map):
        # Load goomba images        
        self.__imgs: list = [
            pygame.image.load('./img/goomba.jpg'),
            pygame.image.load('./img/goomba_death.jpg'),
        ]

        self.image = self.__imgs[0]
        super().__init__(x, y, dir, mario, map)

    
    def update(self):
        # Not update if Mario is dead or growing or shrinking or Game is paused
        if self._mario.status in [Status.DEADING, Status.GROWING, Status.SHRINKING, Status.PAUSE]:
            return

        # Fall handling
        if self._rawrect.y > H:
            self._status = Status.DEAD
        
        if self._status == Status.DEADING:
            self.image = self.__imgs[1]
            # Update rect for Splite
            self.rect = pygame.Rect(self._map.get_drawxentity(self._rawrect), self._rawrect.y, self._rawrect.width, self._rawrect.height)
            self._collapsecount += 1
            if self._collapsecount == 30:
                self._status = Status.DEAD
            return
        
        if self._status == Status.DEAD:
            pass
        
        # Flying if Koopa kick hits goomba
        if self._status == Status.FLYING:
            super().flying()
            # self._rect = self._map.get_drawxenemy(self._rawrect), self._rawrect.top
            self.image = pygame.transform.flip(self.__imgs[0], False, True)
        
        if self._status == Status.NORMAL:
            # X axle move
            self._rawrect.x += self._dir
            
            # X axle collision check
            if self._map.chk_collision(self._rawrect):
                self._rawrect.x = (self._rawrect.x // 20 + (1 if self._dir < 0 else 0)) * 20
                self._dir *= -1
                    
            # Y axle move
            self._vy += 1
            self._rawrect.y += self._vy
                
            # Y axle collision check
            if yx := self._map.chk_collision(self._rawrect):
                self._rawrect.y = (self._rawrect.y // 20 + (1 if self._vy < 0 else 0)) * 20
                # If a block is pushedW
                if self._map.ispushedblock(yx):
                    self._status = Status.FLYING
                    self._dir = 3 if self._rawrect.centerx > self._mario.rawrect.centerx else -3
                    self._vy = -8
                    
                    self.image = pygame.transform.flip(self.__imgs[0], False, True)
                    # Update rect for Splite
                    self.rect = pygame.Rect(self._map.get_drawxentity(self._rawrect), self._rawrect.y, self._rawrect.width, self._rawrect.height)
                    return
                
                if self._vy > 0:
                    self._vy = 0
                else:
                    # jump
                    self._vy = 1

            self._walkidx += 1
            if self._walkidx == self.WALK_SPEED:
                self._walkidx = 0
            
            self.image = pygame.transform.flip(self.__imgs[0], self._walkidx < self.WALK_SPEED // 2, False)
            
            # Collision check
            if self._rawrect.colliderect(self._mario.rawrect):
                super()._handle_mario_hit()
            
            # Koopa kick flying
            super().kickHit()
        
        # Update rect for Splite
        self.rect = pygame.Rect(self._map.get_drawxentity(self._rawrect), self._rawrect.y, self._rawrect.width, self._rawrect.height)


class BrokenBlock(Entity):
    def __init__(self, x, y, dir, vy, mario, map):
        self.__imgs: list = [pygame.image.load('./img/crushed_block.jpg')]
        self.image = self.__imgs[0]
        
        self._rawrect = pygame.Rect(x, y, 10, 10)
        super().__init__(x, y, dir, mario, map)
        self._vy = vy
        
    def update(self):
        super().flying()
        self.rect = pygame.Rect(self._map.get_drawxentity(self._rawrect), self._rawrect.y, self._rawrect.width, self._rawrect.height)


class Star(Entity):
    def __init__(self, x, y, dir, mario, map):
        self.__imgs: list = [pygame.image.load('./img/star.jpg')]
        self.image = self.__imgs[0]
        
        self._rawrect = pygame.Rect(x, y, 20, 20)
        super().__init__(x, y, dir, mario, map)
    
    def update(self):
        # Not update if Mario is dead or growing or shrinking or Game is paused
        if self._mario.status in [Status.DEADING, Status.GROWING, Status.SHRINKING, Status.PAUSE]:
            return
        
        if self._status == Status.NORMAL:
            x, y = self._rawrect.x // 20, self._rawrect.y // 20
            
            if self._map.ispushedblock((y, x)):
                self._status = Status.TREADING
                self._rawrect.y -= 5
            self.image.set_alpha(0)
        elif self._status == Status.TREADING:
            self._walkidx += 1
            if self._walkidx == 4:
                self.image.set_alpha(255)
            if self._walkidx <= 15:
                self._rawrect.y -= 1
            if self._walkidx == 18:
                self._vy = -10
                self._status = Status.FLYING
        elif self._status == Status.FLYING:
            self._rawrect.x += self._dir
            
             # X axle collision check
            if self._map.chk_collision(self._rawrect):
                self._rawrect.x = (self._rawrect.x // 20 + (1 if self._dir < 0 else 0)) * 20
                self._dir *= -1

            # Y axle move
            self._vy += 1
            self._rawrect.y += self._vy
                
            # Y axle collision check
            if self._map.chk_collision(self._rawrect):
                self._rawrect.y = (self._rawrect.y // 20 + (1 if self._vy < 0 else 0)) * 20
                                
                if self._vy > 0:
                    self._vy = -10
                else:
                    # jump
                    self._vy = 0
        
            # Collision check with Mario
            if self._rawrect.colliderect(self._mario.rawrect):
                # Disappear star
                self._status = Status.DEAD
                
                # Prepare for a star mario
                self._mario.hasstar = True
                self._mario.isinvisible = True
                self._mario.invisiblecounter = 240  # 8 seconds
        
        self.rect = pygame.Rect(self._map.get_drawxentity(self._rawrect), self._rawrect.y, self._rawrect.width, self._rawrect.height)


class Fire(Entity):
    def __init__(self, x, y, dir, mario, map):
        self._imgs: list = [
            pygame.image.load('./img/fireball.jpg'),
            pygame.image.load('./img/explode.jpg'),
        ]
        self.image = self._imgs[0]
        
        self._rawrect = pygame.Rect(x, y, 10, 10)
        super().__init__(x, y, dir, mario, map)
    
    def update(self):
        # Not update if Mario is dead or growing or shrinking or Game is paused
        if self._mario.status in [Status.DEADING, Status.GROWING, Status.SHRINKING, Status.PAUSE]:
            return
        
        if self._status == Status.NORMAL:
            # X axle move
            self._rawrect.x += self._dir
                    
            # X axle collision check
            if self._map.chk_collision(self._rawrect):
                self._status = Status.DEAD
                if self in self._mario.arrlies:
                    self._mario.arrlies.remove(self)
                return
            
            # Disappear fire balls when hitting walls/pipes
            if self._rawrect.x < self._map.nowx or self._rawrect.x > self._map.nowx + W:
                self._status = Status.DEAD
                if self in self._mario.arrlies:
                    self._mario.arrlies.remove(self)
                return
            
            # Disappear fire balls for fall handing
            if self._rawrect.y > H:
                self._status = Status.DEAD
                if self in self._mario.arrlies:
                    self._mario.arrlies.remove(self)
                return

            # Y axle move
            self._vy += 1
            self._rawrect.y += self._vy
            
            # Y axle collision check
            if self._map.chk_collision(self._rawrect):
                self._rawrect.y = (self._rawrect.y // 20 + (1 if self._vy < 0 else 0)) * 20
                                    
                if self._vy > 0:
                    self._vy = -5
                else:
                    # jump
                    self._vy = 0
            
            # Add fire ball image animation here
            self.image = pygame.transform.rotate(self._imgs[0], (self._walkidx % 4) * 90)
            self._walkidx += 1
        elif self._status == Status.DEADING:
            # Change to explosion image
            if self._collapsecount < 4:
                self.image = self._imgs[1]
            else:
                self._status = Status.DEAD
                return
            
            self._collapsecount += 1
            
        self.rect = pygame.Rect(self._map.get_drawxentity(self._rawrect), self._rawrect.y, self._rawrect.width, self._rawrect.height)


class Coin(Entity):
    # ANIME_IDX = [0, 1, 2, 3]
    def __init__(self, x, y, dir, mario, map):
        self.__imgs: list = [
            pygame.image.load('./img/coin.jpg'),
        ]
        self.image = self.__imgs[0]
        
        self._rawrect = pygame.Rect(x, y, 20, 20)
        super().__init__(x, y, dir, mario, map)
    
    def update(self):
        # Not update if Mario is dead or growing or shrinking or Game is paused
        if self._mario.status in [Status.DEADING, Status.GROWING, Status.SHRINKING, Status.PAUSE]:
            return
        
        if self._status == Status.NORMAL:
            x, y = self._rawrect.x // 20, self._rawrect.y // 20
            
            # Block with coins is pushed
            if self._map.ispushedblock((y, x)):
                self._map.sound.play_sound_asnync(self._map.sound.play_coin)
                self._map.add_coin()
                self._status = Status.FLYING
                self._vy = -15
                self._rawrect.y -= 20
                return
            # Coin is invisible
            self.image.set_alpha(0)
        
        elif self._status == Status.FLYING:
            # Reset the invisible and coin appears
            self.image.set_alpha(255)
            self._vy += 2
            self._rawrect.y += self._vy
            if self._vy > 10:
                self._status = Status.DEAD
                self._map.group.add(Number(self.rect.x, self.rect.y, 200))
                self._map.add_score(200)
                return
            
            # TODO: Coin animation
            # self.image = self.__imgs[self.ANIME_IDX[self._walkidx]]
            # self._walkidx += 1
    
        self.rect = pygame.Rect(self._map.get_drawxentity(self._rawrect), self._rawrect.y, self._rawrect.width, self._rawrect.height)


class StaticCoin(Entity):
    def __init__(self, x, y, dir, mario, map):
        self.__imgs: list = [
            # TODO: Update the image to meet the sub stage background color
            pygame.image.load('./img/coin.jpg'),
        ]
        self.image = self.__imgs[0]
        
        self._rawrect = pygame.Rect(x, y, 20, 20)
        super().__init__(x, y, dir, mario, map)
    
    def update(self):
        if self._rawrect.colliderect(self._map.mario.rawrect):
            self._status = Status.DEAD
            self._map.sound.play_sound_asnync(self._map.sound.play_coin)
            self._map.add_coin()
        
        self.rect = pygame.Rect(self._map.get_drawxentity(self._rawrect), self._rawrect.y, self._rawrect.width, self._rawrect.height)

class GoalFlag(Entity):
    HEIGHT_RANGE: int = 200  # Cover the goal pole from the top to bottom
    
    def __init__(self, x, y, dir, mario, map):
        self.__imgs: list = [pygame.image.load('./img/goal_flag.jpg')]
        self.image = self.__imgs[0]
        
        self._rawrect = pygame.Rect(x, y, 20, 20)
        super().__init__(x, y, dir, mario, map)
    
    def update(self):
        if self._status == Status.GOAL:
            self._rawrect.y += GOAL_FALL_SPEED
            if self._rawrect.y > GOAL_BOTTOM_Y:
                self._rawrect.y = GOAL_BOTTOM_Y
            
        else:
            # Collision check with Mario
            if pygame.Rect(self._rawrect.x + 20, self._rawrect.y, self._rawrect.width, self.HEIGHT_RANGE).colliderect(self._mario.rawrect):
                self._status = Status.GOAL
                self._mario.status = Status.GOAL
                
                # Adjust Mario position to the goal pole    
                self._mario.rawrect.x = self._rawrect.x
                
                # Set score based on the goal position 
                if self._mario.rawrect.y <= 80:
                    score_idx = 8  # 5000
                elif self._mario.rawrect.y <= 110:
                    score_idx = 6  # 2000
                elif self._mario.rawrect.y <= 140:
                    score_idx = 5  # 1000
                elif self._mario.rawrect.y <= 170:
                    score_idx = 3  # 500
                elif self._mario.rawrect.y <= 200:
                    score_idx = 1  # 200
                else:
                    score_idx = 0  # 100
                
                # Score shows up next to the bottom of the goal pole
                score_number = Number(self._mario.rawrect.x + 20, GOAL_BOTTOM_Y, SCORE_ARRAY[score_idx], self._map)
                score_number.status = Status.GOAL
                self._map.group.add(score_number)
                self._map.add_score(SCORE_ARRAY[score_idx])
                
                # Set timer to goal time
                self._map.goal_time = int(self._map.timer)
                   
        self.rect = pygame.Rect(self._map.get_drawxentity(self._rawrect), self._rawrect.y, self._rawrect.width, self._rawrect.height)

class CastleFlag(Entity):
    POS_Y: int = 140  # Castle Flag position on Y axle
    def __init__(self, x: int, y: int, dir: int, mario: Mario, map: Map, goal_manager: GoalManager):
        self.__imgs: list = [pygame.image.load('./img/castle_flag.jpg')]
        self.image = self.__imgs[0]
        
        self._rawrect = pygame.Rect(x, y, 20, 20)
                
        self.__goal_manager = goal_manager
        self.__goal_manager.castle_flag = self
        
        super().__init__(x, y, dir, mario, map)
    
    def update(self):
        # Mario reaches the goal, then change its status to GOAL
        if self._mario.status == Status.GOAL:
            self._status = Status.GOAL
        else:
            # Image is invisible except goal
            self.image.set_alpha(0)   
        self.rect = pygame.Rect(self._map.get_drawxentity(self._rawrect), self._rawrect.y, self._rawrect.width, self._rawrect.height)
    
    def rise(self):
        # Not execute when its status is not GOAL
        if self._status != Status.GOAL:
            return
        
        if self._rawrect.y <= self.POS_Y:
            # Hold position, stay visible
            self._rawrect.y = self.POS_Y
            self.image.set_alpha(255)
        else:
            self._rawrect.y -= 2
        
class Fireworks(Entity):    
    def __init__(self, x: int, y: int, dir: int, mario: Mario, map: Map, goal_manager: GoalManager):
        self._imgs: list = [pygame.image.load('./img/explode.jpg')]
        self.image = self._imgs[0]
        
        self._rawrect = pygame.Rect(x, y, 10, 10)
        
        self.__goal_manager: GoalManager = goal_manager
        self.__goal_manager.fireworks = self
        self.__counter: int = 0
        
        super().__init__(x, y, dir, mario, map)

    def update(self):
        # Mario reaches the goal, then change its status to GOAL
        if self._mario.status == Status.GOAL:
            self._status = Status.GOAL

        else:
            # Image is invisible except goal
            self.image.set_alpha(0)

        if self.__goal_manager.phase == GoalStatus.FIREWORKS:
            self.image.set_alpha(255)
            # Delete fireworks
            if self.__counter == 30:
                self._status = Status.DEAD
                self.__counter = 0
            self.__counter += 1
            
        self.rect = pygame.Rect(self._map.get_drawxentity(self._rawrect), self._rawrect.y, self._rawrect.width, self._rawrect.height)


class Sound:

    FREQ_C = 261.63  # Sound for (C)
    FREQ_CS = 277.18
    FREQ_D = 293.66  # Sound for (D)
    FREQ_DS = 311.13
    FREQ_E = 329.63  # Sound for (E)
    FREQ_F = 349.23  # Sound for (F)
    FREQ_FS = 369.99
    FREQ_G = 392.00  # Sound for (G)
    FREQ_GS = 415.30
    FREQ_A = 440.00  # Sound for (A)
    FREQ_AS = 466.16
    FREQ_B = 493.88  # Sound for (B)

    def __init__(self):
        self.__sample_rate = 44100

        # Sound for coins
        self.__coin_durations = (0.1, 0.7)
        coin_frequencies = (self.FREQ_B * 2, self.FREQ_E * 4)
        coin_fades = (False, True)
        self.__coin_sounds = self._make_sound(coin_frequencies, self.__coin_durations, coin_fades)

        # Sound for mushrooms
        self.__item_durations = [0.04] * 8
        item_frequencies = (self.FREQ_C, self.FREQ_GS, self.FREQ_CS, self.FREQ_D, self.FREQ_AS, self.FREQ_DS, self.FREQ_AS)
        self.__item_sounds = self._make_sound(item_frequencies, self.__item_durations, [False] * 8)
        
        # Sound for power up
        power_frequencies = (
            self.FREQ_C * 2, self.FREQ_G, self.FREQ_C * 2, self.FREQ_E * 2, self.FREQ_G * 2, self.FREQ_C * 4,
            self.FREQ_G * 2, self.FREQ_GS, self.FREQ_C * 2, self.FREQ_DS * 2, self.FREQ_GS * 2, self.FREQ_E * 2,
            self.FREQ_A * 2, self.FREQ_C * 4, self.FREQ_DS * 4, self.FREQ_GS * 4, self.FREQ_DS * 4, self.FREQ_AS,
            self.FREQ_D * 2, self.FREQ_F * 2, self.FREQ_AS * 2, self.FREQ_F * 2, self.FREQ_B * 2, self.FREQ_D * 4, 
            self.FREQ_AS * 4, self.FREQ_D * 4
        )
        self.__power_durations = [0.05] * len(power_frequencies)
        self.__power_sounds = self._make_sound(power_frequencies, self.__power_durations, [False] * len(self.__power_durations))
        
        # Sound for Clear game
        self.__clear_durations = [0.2] * len(power_frequencies)
        self.__clear_sounds = self._make_sound(power_frequencies, self.__clear_durations, [False] * len(self.__power_durations))
        
        # Sound for a fire ball
        fire_frequencies = (self.FREQ_G, self.FREQ_G * 2, self.FREQ_G * 4)
        self.__fire_durations = [0.02] * len(fire_frequencies)
        self.__fire_sounds = self._make_sound(fire_frequencies, self.__fire_durations, [False] * len(self.__fire_durations))
        
        # Sound for 1 UP
        oneup_frequencies = (self.FREQ_E * 4, self.FREQ_G * 4, self.FREQ_E * 8, self.FREQ_C * 8, self.FREQ_D * 8, self.FREQ_G * 8)
        self.__oneup_durations = [0.1, 0.1, 0.1, 0.1, 0.1, 0.25] 
        self.__oneup_sounds = self._make_sound(oneup_frequencies, self.__oneup_durations, [False, False, False, False, False, False, True])
        
        # TODO: Sound for BGM
        # TODO: Sound for Star Mario
        # TODO: Sound for defeating enemies
        # TODO: Sound for Mario getting damaged
        
    def _make_square_sound(self, frequency, duration, fadeout=False):
        """Generate a sawtooth sound"""
        t = np.linspace(0, duration, int(self.__sample_rate * duration), endpoint=False)
        
        # Create a wave
        waveform = 0.125 * np.sign(np.sin(2 * np.pi * frequency * t))

        if fadeout:
            waveform *= np.exp(-5 * t)
        
        if platform.system() == 'Windows':
            # For windows
            mono = (waveform * 32767).astype(np.int16)
            stereo = np.column_stack((mono, mono))  # duplicate to L/R channels
            return pygame.sndarray.make_sound(stereo)
        else:
            # For mac
            return pygame.sndarray.make_sound(((waveform * 32767)).astype(np.int16))
    
    def _make_sound(self, freqs, durs, fades):
        return [self._make_square_sound(freq, dur, fade) for freq, dur, fade in zip(freqs, durs, fades)]
    
    def play_sound_asnync(self, func):
        threading.Thread(target=func).start()

    def play_sounds(self, sounds, durations):
         for sound, dur in zip(sounds, durations):
            sound.play()
            pygame.time.wait(int(dur * 1000))       

    def play_coin(self):
        self.play_sounds(self.__coin_sounds, self.__coin_durations)
    
    def play_item(self):
        self.play_sounds(self.__item_sounds, self.__item_durations)
        
    def play_power(self):
        self.play_sounds(self.__power_sounds, self.__power_durations)
    
    def play_clear(self):
        self.play_sounds(self.__clear_sounds, self.__clear_durations)
    
    def play_fire(self):
        self.play_sounds(self.__fire_sounds, self.__fire_durations)
    
    def play_oneup(self):
        self.play_sounds(self.__oneup_sounds, self.__oneup_durations)


class Number(pygame.sprite.Sprite):   
    def __init__(self, x: int, y: int, score: int|str, map=None):
        pygame.sprite.Sprite.__init__(self)
        
        font_size: int = 14
        self.__font = pygame.font.SysFont("Arial", font_size)
        self.image: pygame.Surface = self.__create_surface(score)
        self.__counter: int = 0
        self.__status = Status.NORMAL
        
        self.__map = map
        if map is None:
            self.rect = pygame.Rect(x, y, self.image.get_width(), self.image.get_height())
        else:
            # This is for the goal animation
            self.__rawrect = pygame.Rect(x, y, self.image.get_width(), self.image.get_height())
            self.rect = pygame.Rect(self.__map.get_drawxentity(self.__rawrect), self.__rawrect.y, self.__rawrect.width, self.__rawrect.height)
        
    @property
    def status(self):
        return self.__status
    
    @status.setter
    def status(self, value):
        self.__status = value
        
    def __create_surface(self, score):
        """Generate a surface for score"""
        text_surface = self.__font.render(str(score), True, (255, 255, 255))
        surface = pygame.Surface(text_surface.get_size(), pygame.SRCALPHA)
        surface.blit(text_surface, (0, 0))
        return surface

    def update(self):
        if self.__status == Status.NORMAL:
            # Move up
            self.rect.y -= 1
            # Disappear after 1 second
            if self.__counter == 30:
                self.__status = Status.DEAD
                
        if self.__status == Status.GOAL:
            self.rect = pygame.Rect(self.__map.get_drawxentity(self.__rawrect), self.__rawrect.y, self.__rawrect.width, self.__rawrect.height)
            if self.__counter < 32:
                self.__rawrect.y -= GOAL_FALL_SPEED
        
        self.__counter += 1


class HeadUpDisplay:
    def __init__(self) -> None:
        self.__font = pygame.font.SysFont("Arial", size=18)
        
    def __create_text_surface(self, word: str, char_color=(255, 255, 255)) -> pygame.font:
        """
        Create a text surface.
        Args:
            chars (str): Strings to be displayed for the text surface
            char_color (tuple): String color is white as default
                    
        Returns:
            pygame.font: text surface        
        
        """ 
        return self.__font.render(word, True, char_color)
        
    def __display_word(self, win: pygame.display, word: str, x: int, y: int) -> None:
        """Display chars in the window."""
        text_surface = self.__create_text_surface(word)
        win.blit(text_surface, (x, y))
    
    def draw(self, win: pygame.display, score: int, timer: float, coin: int, world: str):
        # Draw heads-up display on the window
        self.__display_word(win, 'MARIO', 30, 10)
        self.__display_word(win, 'WORLD', 180, 10)
        self.__display_word(win, world[5:], 190, 25)
        self.__display_word(win, 'TIME', 260, 10)
        self.__display_word(win, '{:06d}'.format(score), 30, 25)
        self.__display_word(win, 'C x ' + '{:02d}'.format(coin), 100, 25)
        self.__display_word(win, "{:03d}".format(int(timer)), 270, 25)
    
    def draw_game_start(self, win: pygame.display, world: str, life_stocks: int):
        """Draw game start on the window before game starts."""
        # WORLD X-X
        self.__display_word(win, world[:5], 130, 110)
        self.__display_word(win, world[5:], 180, 110)
        
        # Mario image x life stocks
        self.__display_word(win, ' x ', 160, 140)
        self.__display_word(win, str(life_stocks), 180, 140)

    def draw_game_over(self, win: pygame.display):
        """Draw game over on the window."""
        self.__display_word(win, 'GAMEOVER', 120, 140)
    
    def draw_pause(self, win: pygame.display) -> None:
        """Draw Pause on the window"""
        self.__display_word(win, 'PAUSE', 120, 140)

            
def init():
    # Define Sprite group
    group = pygame.sprite.RenderUpdates()
    group_bg = pygame.sprite.RenderUpdates()
    
    # Map class
    map = Map(group, group_bg, Sound(), HeadUpDisplay(), "World1-1")
    
    # Mario class
    mario = Mario(map, group)
    
    # TODO: Ask a player which World the player wants to play
    goal_manager = GoalManager("World1-1", mario, map)
    
    return group, group_bg, mario, map, goal_manager


def main():
    """main function"""
    
    # TODO: Add a start menu where a player choose a stage
        
    # Initialize pygame
    pygame.mixer.pre_init(frequency=44100, size=-16, channels=1)
    pygame.init()
    
    # Build a display
    win = pygame.display.set_mode((W, H))
    
    # Create clock rate
    clock = pygame.time.Clock()
    
    # Initialize sprite
    group, group_bg, mario, map, goal_manager = init()
    
    # Event loop
    running = True
    while running:
        for e in pygame.event.get():
            if e.type == pygame.QUIT:
                running = False

            elif e.type == pygame.KEYDOWN:
                # Release a fire ball
                if e.key == pygame.K_LSHIFT and mario.isfire:
                    mario.fire()

                # Game is paused when "p" is pushed
                elif e.key == pygame.K_p and mario.status == Status.NORMAL:
                    mario.status = Status.PAUSE
                elif e.key == pygame.K_p and mario.status == Status.PAUSE:
                    mario.status = Status.NORMAL
        
        # Update the group_bg
        group_bg.update()
        
        # Update the group
        group.update()
        
        # Update Mario
        mario.update()
        
        # Goal animation
        if mario.status == Status.GOAL:
            if not goal_manager.isactive:
                goal_manager.isactive = True
           
            goal_manager.update()

        # Temporary end when Game is clear
        if mario.status == Status.CLEAR:
            running = False
            continue
         
        # Game begins again!
        if mario.status == Status.INIT:
            group, group_bg, mario, map, goal_manager = init()
            continue 
        
        # Mario is dead and the life stocks is not 0
        elif mario.status == Status.DEAD:
            group, group_bg = mario.init_dead()
            continue
        
        # The life stocks is 0
        elif mario.status == Status.GAMEOVER:
            group.empty()
            group_bg.empty()
        
        # Remove DEAD status
        for entity in group.sprites():
            if entity.status == Status.DEAD:
                group.remove(entity)
        
        for entity_bg in group_bg.sprites():
            if entity_bg.status == Status.DEAD:
                group_bg.remove(entity_bg)
    
        # Fill in the background     
        map.fill(win)

        # Draw the group_bg
        group_bg.draw(win)
             
        # Draw map
        map.draw(win, mario.rawrect)
        
        # Draw the group
        group.draw(win)
        
        # Draw Mario
        mario.draw(win)

        # Update the display
        pygame.display.flip()

        # Frame rate
        clock.tick(30)
    
    # End pygame
    pygame.quit()
                

if __name__ == '__main__':
    main()
    